const fileInput = document.getElementById("fileInput");
const uploadArea = document.getElementById("uploadArea");
const uploadMessage = document.getElementById("uploadMessage");
const trainerSection = document.getElementById("trainerSection");
const vocabList = document.getElementById("vocabList");
const checkBtn = document.getElementById("checkBtn");
const clearBtn = document.getElementById("clearBtn");
const resultMessage = document.getElementById("resultMessage");
const imprintToggle = document.getElementById("imprintToggle");
const imprintPanel = document.getElementById("imprintPanel");

let vocabData = [];

const ACCEPTED_FILENAME = "vokabeln.txt";
const ACCEPTED_EXCEL_FILENAMES = new Set(["vokabeln.xlsx", "vokabeln.xls"]);
const MAX_ENTRIES = 50;
const textDecoder = new TextDecoder("utf-8");
const xmlParser = new DOMParser();

const LENGTH_BASES = [
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,
  83, 99, 115, 131, 163, 195, 227, 258,
];
const LENGTH_EXTRA_BITS = [
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0,
];
const DIST_BASES = [
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
  1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,
];
const DIST_EXTRA_BITS = [
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13,
];
const CODE_LENGTH_ORDER = [
  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
];

const fixedHuffmanTrees = createFixedHuffmanTrees();

fileInput.addEventListener("change", (event) => {
  const [file] = event.target.files;
  processFile(file);
});

uploadArea.addEventListener("dragover", (event) => {
  event.preventDefault();
  uploadArea.classList.add("dragover");
});

uploadArea.addEventListener("dragleave", () => {
  uploadArea.classList.remove("dragover");
});

uploadArea.addEventListener("drop", (event) => {
  event.preventDefault();
  uploadArea.classList.remove("dragover");

  const file = event.dataTransfer.files[0];
  if (!file) {
    return;
  }

  // Reflect dropped file in the hidden input for accessibility.
  if (typeof DataTransfer !== "undefined") {
    const transfer = new DataTransfer();
    transfer.items.add(file);
    fileInput.files = transfer.files;
  }

  processFile(file);
});

checkBtn.addEventListener("click", () => compareAnswers());
clearBtn.addEventListener("click", () => clearAnswers(true));
imprintToggle.addEventListener("click", () => toggleImprint());

function processFile(file) {
  resetFeedback();
  resultMessage.classList.remove("visible", "success", "error");
  resultMessage.textContent = "";

  if (!file) {
    return;
  }

  const extension = getExtension(file.name);

  if (extension === "txt") {
    if (file.name !== ACCEPTED_FILENAME) {
      showFeedback(uploadMessage, "error", `The text file must be named <strong>${ACCEPTED_FILENAME}</strong>. Please rename it and try again.`);
      resetFileInput();
      hideTrainer();
      return;
    }
    readTextFile(file);
    return;
  }

  if (extension === "xlsx" || extension === "xls") {
    if (!ACCEPTED_EXCEL_FILENAMES.has(file.name.toLowerCase())) {
      const expectedName = extension === "xls" ? "vokabeln.xls" : "vokabeln.xlsx";
      showFeedback(
        uploadMessage,
        "error",
        `The Excel file must be named <strong>${expectedName}</strong>. Please rename it and try again.`
      );
      resetFileInput();
      hideTrainer();
      return;
    }
    showFeedback(uploadMessage, "info", "Processing Excel file â€¦");
    readExcelFile(file);
    return;
  }

  showFeedback(uploadMessage, "error", "Unsupported file type. Please upload <strong>vokabeln.txt</strong> or an Excel file (.xlsx).");
  hideTrainer();
  resetFileInput();
}

function parseVocabulary(text) {
  const lines = text.split(/\r?\n/);
  const entries = [];
  let skipped = 0;

  for (const [index, rawLine] of lines.entries()) {
    const line = rawLine.trim();
    if (!line) {
      continue;
    }

    const parts = line.split(";");
    if (parts.length !== 2) {
      skipped += 1;
      continue;
    }

    const german = parts[0].trim();
    const english = parts[1].trim();

    if (!german || !english) {
      skipped += 1;
      continue;
    }

    entries.push({
      german,
      english,
      line: index + 1,
    });
  }

  return { entries, skipped };
}

function renderVocabulary(entries) {
  vocabList.innerHTML = "";

  entries.forEach((entry, index) => {
    const row = document.createElement("div");
    row.className = "vocab-item";

    const germanLabel = document.createElement("span");
    germanLabel.textContent = entry.german;

    const englishInput = document.createElement("input");
    englishInput.type = "text";
    englishInput.name = `vocab-${index}`;
    englishInput.placeholder = "Enter target word";
    englishInput.autocomplete = "off";
    englishInput.dataset.answer = entry.english;
    englishInput.dataset.german = entry.german;

    englishInput.addEventListener("input", () => {
      englishInput.classList.remove("correct", "incorrect");
      resultMessage.classList.remove("visible", "success", "error");
      resultMessage.textContent = "";
    });

    row.appendChild(germanLabel);
    row.appendChild(englishInput);
    vocabList.appendChild(row);
  });
}

function compareAnswers() {
  const inputs = vocabList.querySelectorAll("input");
  if (!inputs.length) {
    return;
  }

  let correctCount = 0;
  const incorrectWords = [];

  inputs.forEach((input) => {
    const userAnswer = input.value.trim();
    const solution = input.dataset.answer.trim();

    if (!userAnswer) {
      input.classList.remove("correct");
      input.classList.add("incorrect");
      incorrectWords.push(`${input.dataset.german} (missing target word)`);
      return;
    }

    if (normalize(userAnswer) === normalize(solution)) {
      input.classList.remove("incorrect");
      input.classList.add("correct");
      correctCount += 1;
    } else {
      input.classList.remove("correct");
      input.classList.add("incorrect");
      incorrectWords.push(`${input.dataset.german} -> ${solution}`);
    }
  });

  const total = inputs.length;
  const allCorrect = correctCount === total;

  showFeedback(
    resultMessage,
    allCorrect ? "success" : "error",
    allCorrect
      ? "Great job - every target word is correct!"
      : buildErrorMessage(correctCount, total, incorrectWords)
  );
}

function buildErrorMessage(correctCount, total, incorrectWords) {
  const mistakes =
    incorrectWords.length > 0
      ? `<br><span class="details">Needs review: ${incorrectWords.join(
          ", "
        )}</span>`
      : "";

  return `You got ${correctCount} of ${total} answers right.${mistakes}`;
}

function clearAnswers(showConfirmation = false) {
  const inputs = vocabList.querySelectorAll("input");
  inputs.forEach((input) => {
    input.value = "";
    input.classList.remove("correct", "incorrect");
  });

  if (showConfirmation) {
    showFeedback(resultMessage, "success", "All fields cleared.");
  } else {
    resultMessage.classList.remove("visible", "success", "error");
    resultMessage.textContent = "";
  }
}

function hideTrainer() {
  trainerSection.classList.add("hidden");
  vocabList.innerHTML = "";
  toggleTrainerButtons(false);
}

function toggleTrainerButtons(enable) {
  checkBtn.disabled = !enable;
  clearBtn.disabled = !enable;
}

function normalize(text) {
  const lowered = text.toLocaleLowerCase("de-DE").normalize("NFD");
  try {
    return lowered.replace(/\p{Diacritic}/gu, "");
  } catch (error) {
    return lowered;
  }
}

function showFeedback(element, type, message) {
  element.classList.remove("success", "error", "info", "visible");
  element.innerHTML = message;
  element.classList.add(type, "visible");
}

function resetFeedback() {
  uploadMessage.classList.remove("success", "error", "info", "visible");
  uploadMessage.textContent = "";
}

function resetFileInput() {
  fileInput.value = "";
}

function readTextFile(file) {
  const reader = new FileReader();
  reader.onload = () => {
    const text = reader.result;
    const { entries, skipped } = parseVocabulary(text);
    handleParsedEntries(entries, {
      skipped,
      source: "text",
    });
  };

  reader.onerror = () => {
    showFeedback(uploadMessage, "error", "The text file could not be read. Please try again.");
    hideTrainer();
  };

  reader.readAsText(file, "UTF-8");
}

async function readExcelFile(file) {
  if (!supportsZipDecompression()) {
    showFeedback(
      uploadMessage,
      "error",
      "Excel decoding needs a modern browser. Please update your browser or upload vokabeln.txt instead."
    );
    hideTrainer();
    return;
  }

  try {
    const buffer = await fileToArrayBuffer(file);
    const bytes = new Uint8Array(buffer);
    const zip = createZipReader(bytes);
    const workbookXml = await zip.getText("xl/workbook.xml");
    if (!workbookXml) {
      showFeedback(uploadMessage, "error", "The Excel file is missing workbook information.");
      hideTrainer();
      return;
    }

    const workbookDoc = xmlParser.parseFromString(workbookXml, "application/xml");
    const sheets = getElementsByTagNameSafe(workbookDoc, "sheet");
    const firstSheet = sheets.length ? sheets[0] : null;
    if (!firstSheet) {
      showFeedback(uploadMessage, "error", "No worksheets found inside the Excel file.");
      hideTrainer();
      return;
    }

    const relId = firstSheet.getAttribute("r:id");
    const relsXml = await zip.getText("xl/_rels/workbook.xml.rels");
    const targetPath = normalizeSheetPath(relId && relsXml ? getRelationshipTarget(relsXml, relId) : null);

    let sheetXml = await zip.getText(targetPath);
    if (!sheetXml && !targetPath.startsWith("xl/")) {
      sheetXml = await zip.getText(`xl/${targetPath}`);
    }
    if (!sheetXml) {
      showFeedback(uploadMessage, "error", "The first worksheet could not be read.");
      hideTrainer();
      return;
    }

    const sharedStringsXml = await zip.getText("xl/sharedStrings.xml");
    const sharedStrings = parseSharedStrings(sharedStringsXml);
    const rows = extractRowsFromSheet(sheetXml, sharedStrings);
    const { entries, skipped } = extractEntriesFromRows(rows);
    handleParsedEntries(entries, {
      skipped,
      source: "excel",
    });
  } catch (error) {
    console.error(error);
    showFeedback(
      uploadMessage,
      "error",
      `The Excel file could not be processed. ${error && error.message ? error.message : "Please check the format and try again."}`
    );
    hideTrainer();
  }
}

function supportsZipDecompression() {
  return (
    typeof DecompressionStream !== "undefined" ||
    typeof inflateRaw === "function"
  );
}

function createZipReader(bytes) {
  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  const eocdOffset = findEndOfCentralDirectory(view);
  if (eocdOffset < 0) {
    throw new Error("Invalid ZIP structure.");
  }

  const totalEntries = view.getUint16(eocdOffset + 10, true);
  const centralDirectoryOffset = view.getUint32(eocdOffset + 16, true);

  const entries = new Map();
  let pointer = centralDirectoryOffset;

  for (let index = 0; index < totalEntries; index += 1) {
    const signature = view.getUint32(pointer, true);
    if (signature !== 0x02014b50) {
      throw new Error("Unexpected central directory signature.");
    }

    const compressedSize = view.getUint32(pointer + 20, true);
    const fileNameLength = view.getUint16(pointer + 28, true);
    const extraLength = view.getUint16(pointer + 30, true);
    const commentLength = view.getUint16(pointer + 32, true);
    const localHeaderOffset = view.getUint32(pointer + 42, true);
    const nameBytes = bytes.subarray(pointer + 46, pointer + 46 + fileNameLength);
    const fileName = textDecoder.decode(nameBytes);

    pointer += 46 + fileNameLength + extraLength + commentLength;

    const localSignature = view.getUint32(localHeaderOffset, true);
    if (localSignature !== 0x04034b50) {
      continue;
    }

    const generalPurpose = view.getUint16(localHeaderOffset + 6, true);
    const compressionMethod = view.getUint16(localHeaderOffset + 8, true);
    const fileNameLenLocal = view.getUint16(localHeaderOffset + 26, true);
    const extraLenLocal = view.getUint16(localHeaderOffset + 28, true);
    const dataOffset = localHeaderOffset + 30 + fileNameLenLocal + extraLenLocal;
    const compressedData = bytes.subarray(dataOffset, dataOffset + compressedSize);

    entries.set(fileName, {
      compressionMethod,
      compressedData,
      generalPurpose,
      cache: null,
    });
  }

  return {
    async getBytes(name) {
      const entry = entries.get(name);
      if (!entry) {
        return null;
      }
      if (entry.cache) {
        return entry.cache;
      }
      const data = await decompressEntry(entry);
      entry.cache = data;
      return data;
    },
    async getText(name) {
      const bytesResult = await this.getBytes(name);
      return bytesResult ? textDecoder.decode(bytesResult) : null;
    },
  };
}

async function decompressEntry(entry) {
  if (entry.compressionMethod === 0) {
    return entry.compressedData.slice();
  }

  if (entry.compressionMethod === 8) {
    if (typeof DecompressionStream !== "undefined") {
      const stream = new DecompressionStream("deflate-raw");
      const writer = stream.writable.getWriter();
      await writer.write(entry.compressedData);
      await writer.close();
      const buffer = await new Response(stream.readable).arrayBuffer();
      return new Uint8Array(buffer);
    }
    return inflateRaw(entry.compressedData);
  }

  throw new Error(`Unsupported compression method: ${entry.compressionMethod}`);
}

function findEndOfCentralDirectory(view) {
  for (let offset = view.byteLength - 22; offset >= 0; offset -= 1) {
    if (view.getUint32(offset, true) === 0x06054b50) {
      return offset;
    }
  }
  return -1;
}

function normalizeSheetPath(target) {
  if (!target) {
    return "xl/worksheets/sheet1.xml";
  }

  const raw = target.startsWith("/") ? target.slice(1) : `xl/${target}`;
  const segments = raw.split("/");
  const stack = [];

  for (const segment of segments) {
    if (!segment || segment === ".") {
      continue;
    }
    if (segment === "..") {
      stack.pop();
      continue;
    }
    stack.push(segment);
  }

  return stack.join("/");
}

function getRelationshipTarget(relsXml, relId) {
  if (!relsXml) {
    return null;
  }

  try {
    const relsDoc = xmlParser.parseFromString(relsXml, "application/xml");
    const relationships = relsDoc.getElementsByTagName("Relationship");
    for (const rel of relationships) {
      if (rel.getAttribute("Id") === relId) {
        return rel.getAttribute("Target");
      }
    }
  } catch (error) {
    console.error(error);
  }

  return null;
}

function parseSharedStrings(xml) {
  if (!xml) {
    return [];
  }

  const doc = xmlParser.parseFromString(xml, "application/xml");
  const sharedStrings = [];
  const items = getElementsByTagNameSafe(doc, "si");

  for (const item of items) {
    let text = "";
    const textNodes = getElementsByTagNameSafe(item, "t");
    for (const node of textNodes) {
      text += node.textContent || "";
    }
    sharedStrings.push(text.trim());
  }

  return sharedStrings;
}

function extractRowsFromSheet(sheetXml, sharedStrings) {
  if (!sheetXml) {
    return [];
  }

  const doc = xmlParser.parseFromString(sheetXml, "application/xml");
  const rowNodes = getElementsByTagNameSafe(doc, "row");
  const rows = [];

  for (const rowNode of rowNodes) {
    const rowData = ["", ""];
    const cellNodes = getElementsByTagNameSafe(rowNode, "c");
    let fallbackIndex = 0;

    for (const cellNode of cellNodes) {
      const ref = cellNode.getAttribute("r") || "";
      let colIndex = columnNameToIndex(ref);
      if (Number.isNaN(colIndex) || colIndex < 0) {
        colIndex = fallbackIndex;
      }
      fallbackIndex += 1;

      if (colIndex > 1) {
        continue;
      }

      const value = readCellValue(cellNode, sharedStrings);
      rowData[colIndex] = value;
    }

    if (rowData[0] || rowData[1]) {
      rows.push(rowData);
    }
  }

  return rows;
}

function columnNameToIndex(reference) {
  if (!reference) {
    return NaN;
  }

  const match = reference.match(/[A-Za-z]+/);
  if (!match) {
    return NaN;
  }

  const letters = match[0].toUpperCase();
  let index = 0;

  for (let i = 0; i < letters.length; i += 1) {
    index = index * 26 + (letters.charCodeAt(i) - 64);
  }

  return index - 1;
}

function readCellValue(cellNode, sharedStrings) {
  const type = cellNode.getAttribute("t");

  if (type === "s") {
    const valueNode = getElementsByTagNameSafe(cellNode, "v")[0];
    if (!valueNode) {
      return "";
    }
    const sharedIndex = Number(valueNode.textContent || "0");
    return sharedStrings[sharedIndex] || "";
  }

  if (type === "inlineStr") {
    const textNodes = getElementsByTagNameSafe(cellNode, "t");
    let inline = "";
    for (const node of textNodes) {
      inline += node.textContent || "";
    }
    return inline.trim();
  }

  const valueNode = getElementsByTagNameSafe(cellNode, "v")[0];
  if (!valueNode) {
    return "";
  }

  return (valueNode.textContent || "").trim();
}

function extractEntriesFromRows(rows) {
  const entries = [];
  let skipped = 0;
  let processedRows = 0;

  for (const row of rows) {
    processedRows += 1;

    if (!Array.isArray(row)) {
      skipped += 1;
      continue;
    }

    const source = toCellValue(row[0]);
    const target = toCellValue(row[1]);

    if (!source || !target) {
      skipped += 1;
      continue;
    }

    entries.push({
      german: source,
      english: target,
      line: entries.length + 1,
    });

    if (entries.length === MAX_ENTRIES) {
      const remaining = rows.length - processedRows;
      if (remaining > 0) {
        skipped += remaining;
      }
      break;
    }
  }

  return { entries, skipped };
}

function toCellValue(cell) {
  if (cell === undefined || cell === null) {
    return "";
  }

  return String(cell).trim();
}

function handleParsedEntries(entries, { skipped, source }) {
  if (!entries.length) {
    showFeedback(
      uploadMessage,
      "error",
      source === "text"
        ? "No valid vocabulary pairs were found in the text file."
        : "No valid vocabulary pairs were found in the spreadsheet."
    );
    hideTrainer();
    return;
  }

  vocabData = entries.slice(0, MAX_ENTRIES);
  renderVocabulary(vocabData);
  showFeedback(
    uploadMessage,
    "success",
    skipped
      ? `Loaded ${vocabData.length} entries. Skipped ${skipped} row(s) that were empty, incomplete, or beyond the 50-row limit.`
      : `Loaded ${vocabData.length} entries. Time to practice!`
  );
  trainerSection.classList.remove("hidden");
  toggleTrainerButtons(true);
  clearAnswers();
  resetFileInput();
}

// Allow keyboard activation of the upload area for accessibility.
uploadArea.addEventListener("keydown", (event) => {
  if (event.key === "Enter" || event.key === " ") {
    event.preventDefault();
    fileInput.click();
  }
});

function toggleImprint() {
  const isHidden = imprintPanel.hasAttribute("hidden");
  if (isHidden) {
    imprintPanel.removeAttribute("hidden");
    imprintToggle.setAttribute("aria-expanded", "true");
    imprintToggle.textContent = "Hide imprint";
    imprintPanel.scrollIntoView({ behavior: "smooth", block: "nearest" });
  } else {
    imprintPanel.setAttribute("hidden", "");
    imprintToggle.setAttribute("aria-expanded", "false");
    imprintToggle.textContent = "Show imprint";
  }
}

function getExtension(filename = "") {
  const parts = filename.toLowerCase().split(".");
  return parts.length > 1 ? parts.pop() : "";
}

function inflateRaw(input) {
  let position = 0;
  let bitBuffer = 0;
  let bitLength = 0;

  const ensureBits = (count) => {
    while (bitLength < count) {
      if (position >= input.length) {
        throw new Error("Unexpected end of data while inflating.");
      }
      bitBuffer |= input[position] << bitLength;
      position += 1;
      bitLength += 8;
    }
  };

  const readBits = (count) => {
    ensureBits(count);
    const value = bitBuffer & ((1 << count) - 1);
    bitBuffer >>>= count;
    bitLength -= count;
    return value;
  };

  const alignToByte = () => {
    bitBuffer = 0;
    bitLength = 0;
  };

  const decodeSymbol = (tree) => {
    if (tree.value !== undefined) {
      return tree.value;
    }

    let node = tree;
    while (node.value === undefined) {
      const bit = readBits(1);
      node = node[bit];
      if (!node) {
        throw new Error("Invalid Huffman code encountered.");
      }
    }
    return node.value;
  };

  const output = [];
  let isFinalBlock = false;

  while (!isFinalBlock) {
    isFinalBlock = readBits(1) === 1;
    const blockType = readBits(2);

    if (blockType === 0) {
      alignToByte();
      if (position + 4 > input.length) {
        throw new Error("Stored block header incomplete.");
      }
      const len = input[position] | (input[position + 1] << 8);
      const nlen = input[position + 2] | (input[position + 3] << 8);
      position += 4;

      if ((len ^ 0xffff) !== nlen) {
        throw new Error("Stored block length check failed.");
      }

      if (position + len > input.length) {
        throw new Error("Stored block exceeds input length.");
      }

      for (let i = 0; i < len; i += 1) {
        output.push(input[position + i]);
      }
      position += len;
      continue;
    }

    if (blockType !== 1 && blockType !== 2) {
      throw new Error("Unsupported DEFLATE block type.");
    }

    let literalTree;
    let distanceTree;

    if (blockType === 1) {
      literalTree = fixedHuffmanTrees.literal;
      distanceTree = fixedHuffmanTrees.distance;
    } else {
      const hlit = readBits(5) + 257;
      const hdist = readBits(5) + 1;
      const hclen = readBits(4) + 4;

      const codeLengthCodes = new Array(19).fill(0);
      for (let index = 0; index < hclen; index += 1) {
        codeLengthCodes[CODE_LENGTH_ORDER[index]] = readBits(3);
      }

      const codeLengthTree = buildHuffmanTree(codeLengthCodes);
      const totalCodes = hlit + hdist;
      const codeLengths = [];

      while (codeLengths.length < totalCodes) {
        const symbol = decodeSymbol(codeLengthTree);

        if (symbol <= 15) {
          codeLengths.push(symbol);
          continue;
        }

        if (symbol === 16) {
          if (!codeLengths.length) {
            throw new Error("Invalid repeat code in Huffman specification.");
          }
          const repeat = readBits(2) + 3;
          const previous = codeLengths[codeLengths.length - 1];
          for (let i = 0; i < repeat; i += 1) {
            codeLengths.push(previous);
          }
          continue;
        }

        if (symbol === 17) {
          const repeat = readBits(3) + 3;
          for (let i = 0; i < repeat; i += 1) {
            codeLengths.push(0);
          }
          continue;
        }

        if (symbol === 18) {
          const repeat = readBits(7) + 11;
          for (let i = 0; i < repeat; i += 1) {
            codeLengths.push(0);
          }
          continue;
        }

        throw new Error("Invalid code length symbol.");
      }

      const literalCodeLengths = codeLengths.slice(0, hlit);
      const distanceCodeLengths = codeLengths.slice(hlit, totalCodes);

      if (distanceCodeLengths.every((len) => len === 0)) {
        distanceCodeLengths[0] = 1;
      }

      literalTree = buildHuffmanTree(literalCodeLengths);
      distanceTree = buildHuffmanTree(distanceCodeLengths);
    }

    while (true) {
      const symbol = decodeSymbol(literalTree);

      if (symbol === 256) {
        break;
      }

      if (symbol < 256) {
        output.push(symbol);
        continue;
      }

      const lengthIndex = symbol - 257;
      if (lengthIndex < 0 || lengthIndex >= LENGTH_BASES.length) {
        throw new Error("Invalid length code encountered.");
      }

      const length =
        LENGTH_BASES[lengthIndex] + readBits(LENGTH_EXTRA_BITS[lengthIndex]);
      const distanceSymbol = decodeSymbol(distanceTree);

      if (distanceSymbol < 0 || distanceSymbol >= DIST_BASES.length) {
        throw new Error("Invalid distance code encountered.");
      }

      const distance =
        DIST_BASES[distanceSymbol] + readBits(DIST_EXTRA_BITS[distanceSymbol]);
      if (distance <= 0 || distance > output.length) {
        throw new Error("Invalid distance in back-reference.");
      }

      const start = output.length - distance;
      for (let i = 0; i < length; i += 1) {
        output.push(output[start + i]);
      }
    }
  }

  return Uint8Array.from(output);
}

function fileToArrayBuffer(file) {
  if (typeof file.arrayBuffer === "function") {
    return file.arrayBuffer();
  }

  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(new Error("The Excel file could not be read."));
    reader.readAsArrayBuffer(file);
  });
}

function buildHuffmanTree(lengths) {
  let maxBits = 0;
  for (const length of lengths) {
    if (length > maxBits) {
      maxBits = length;
    }
  }

  if (maxBits === 0) {
    const valueIndex = lengths.findIndex((length) => length > 0);
    return {
      value: valueIndex >= 0 ? valueIndex : 0,
    };
  }

  const blCount = new Array(maxBits + 1).fill(0);
  lengths.forEach((length) => {
    if (length > 0) {
      blCount[length] += 1;
    }
  });

  const nextCode = new Array(maxBits + 1).fill(0);
  let code = 0;
  for (let bits = 1; bits <= maxBits; bits += 1) {
    code = (code + (blCount[bits - 1] || 0)) << 1;
    nextCode[bits] = code;
  }

  const root = {};

  lengths.forEach((length, symbol) => {
    if (length === 0) {
      return;
    }

    let node = root;
    let codeValue = nextCode[length];
    nextCode[length] += 1;

    for (let bitIndex = length - 1; bitIndex >= 0; bitIndex -= 1) {
      const bit = (codeValue >> bitIndex) & 1;
      node[bit] = node[bit] || {};
      node = node[bit];
    }

    node.value = symbol;
  });

  return root;
}

function createFixedHuffmanTrees() {
  const literalLengths = new Array(288);

  for (let i = 0; i <= 143; i += 1) {
    literalLengths[i] = 8;
  }
  for (let i = 144; i <= 255; i += 1) {
    literalLengths[i] = 9;
  }
  for (let i = 256; i <= 279; i += 1) {
    literalLengths[i] = 7;
  }
  for (let i = 280; i <= 287; i += 1) {
    literalLengths[i] = 8;
  }

  const distanceLengths = new Array(32).fill(5);

  return {
    literal: buildHuffmanTree(literalLengths),
    distance: buildHuffmanTree(distanceLengths),
  };
}

function getElementsByTagNameSafe(node, tagName) {
  if (!node || typeof node.getElementsByTagName !== "function") {
    return [];
  }

  const direct = node.getElementsByTagName(tagName);
  if (direct && direct.length) {
    return Array.from(direct);
  }

  if (typeof node.getElementsByTagNameNS === "function") {
    const namespaceList = [
      "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "*",
    ];

    for (const ns of namespaceList) {
      try {
        const nsNodes = node.getElementsByTagNameNS(ns, tagName);
        if (nsNodes && nsNodes.length) {
          return Array.from(nsNodes);
        }
      } catch (error) {
        // Ignore namespace lookup errors and continue.
      }
    }
  }

  return [];
}

